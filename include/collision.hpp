#pragma once

#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <cassert>

//==========================================================================================//
//                                                                                          //
//  This code was mostly generated by chatgpt and modified a bit to fit my needs            //
//  but I would not be proficient enough in the math to write this completely on my own     //
//                                                                                          //
//==========================================================================================//

// Vector2 class
struct Vector2 {
    float x, y;

    Vector2 operator+(const Vector2& other) const {
        return {x + other.x, y + other.y};
    }

    Vector2 operator-(const Vector2& other) const {
        return {x - other.x, y - other.y};
    }

    Vector2 operator-() const {
        return {-x, -y};
    }

    Vector2 operator*(float scalar) const {
        return {x * scalar, y * scalar};
    }

    float dot(const Vector2& other) const {
        return x * other.x + y * other.y;
    }

    float length() const {
        return std::sqrt(x * x + y * y);
    }

    Vector2 normalize() const {
        float len = length();
        return len > 0 ? (*this) * (1.0f / len) : Vector2{0, 0};
    }

    Vector2 perpendicular() const {
        return {-y, x};
    }
};

// Support function for convex shapes
Vector2 support(const std::vector<Vector2>& shape, const Vector2& direction) {
    float maxDot = -std::numeric_limits<float>::infinity();
    Vector2 bestPoint;
    for (const auto& point : shape) {
        float dotProduct = point.dot(direction);
        if (dotProduct > maxDot) {
            maxDot = dotProduct;
            bestPoint = point;
        }
    }
    return bestPoint;
}

// GJK Algorithm for collision detection
bool gjkCollision(const std::vector<Vector2>& shapeA, const std::vector<Vector2>& shapeB) {
    Vector2 direction = {1, 0};
    Vector2 point = support(shapeA, direction) - support(shapeB, -direction);
    std::vector<Vector2> simplex = {point};

    direction = -point;

    while (true) {
        point = support(shapeA, direction) - support(shapeB, -direction);
        if (point.dot(direction) <= 0) {
            return false; // No collision
        }

        simplex.push_back(point);

        if (simplexContainsOrigin(simplex, direction)) {
            return true; // Collision detected
        }
    }
}

// Check if simplex contains origin and adjust the direction
bool simplexContainsOrigin(std::vector<Vector2>& simplex, Vector2& direction) {
    const Vector2& a = simplex.back();
    Vector2 ao = -a;

    if (simplex.size() == 2) {
        const Vector2& b = simplex[0];
        Vector2 ab = b - a;
        direction = ab.perpendicular().dot(ao) > 0 ? ab.perpendicular() : -ab.perpendicular();
    } else if (simplex.size() == 3) {
        const Vector2& b = simplex[1];
        const Vector2& c = simplex[0];

        Vector2 ab = b - a;
        Vector2 ac = c - a;

        Vector2 abPerp = ab.perpendicular();
        Vector2 acPerp = ac.perpendicular();

        if (abPerp.dot(ao) > 0) {
            simplex = {b, a};
            direction = abPerp;
        } else if (acPerp.dot(ao) > 0) {
            simplex = {c, a};
            direction = acPerp;
        } else {
            return true;
        }
    }
    return false;
}

// Resolve collision by separating overlapping shapes
void resolveCollision(std::vector<Vector2>& shapeA, std::vector<Vector2>& shapeB) {
    Vector2 direction = {1, 0};
    Vector2 mtv; // Minimum Translation Vector

    for (int i = 0; i < 10; ++i) { // Iterative refinement
        Vector2 supportA = support(shapeA, direction);
        Vector2 supportB = support(shapeB, -direction);
        Vector2 minkowskiPoint = supportA - supportB;

        float penetration = minkowskiPoint.dot(direction);
        if (penetration > 0) {
            mtv = direction * penetration;
            break;
        }
        direction = -minkowskiPoint.normalize();
    }

    for (auto& point : shapeA) {
        point = point - mtv * 0.5f; // Push shapeA back
    }
    for (auto& point : shapeB) {
        point = point + mtv * 0.5f; // Push shapeB forward
    }
}

// Example of integrating with a game loop
/* int main() {
    std::vector<Vector2> shapeA = {{0, 0}, {1, 0}, {0, 1}}; // Triangle
    std::vector<Vector2> shapeB = {{1, 1}, {2, 1}, {1, 2}}; // Triangle

    // Simulate an update loop
    for (int i = 0; i < 10; ++i) {
        if (gjkCollision(shapeA, shapeB)) {
            std::cout << "Collision detected at step " << i << "!\n";
            resolveCollision(shapeA, shapeB);
        } else {
            std::cout << "No collision at step " << i << "\n";
        }

        // Simulate movement
        for (auto& point : shapeA) point.x += 0.1f;
        for (auto& point : shapeB) point.y -= 0.1f;
    }

    return 0;
} */